
//listy leniwe**************************************************************************************************************************
type 'a llist = LNil | LCons of 'a * (unit -> 'a llist);;

let lhd = function
LNil -> failwith "lhd"
| LCons (x, _) -> x
;;

let ltl = function
LNil -> failwith "ltl"
| LCons (_, xf) -> xf()
;;

let rec lfrom k = LCons (k, function () -> lfrom (k+1));;
let rec ltake = function
(0, _) -> []
| (_, LNil) -> []
| (n, LCons(x,xf)) -> x::ltake(n-1, xf())
;;

ltake (5,lfrom 30);;

let rec toLazyList = function
[] -> LNil
h::t -> LCons(h, function () -> toLazyList t);;

let rec (@$) ll1 ll2 =
match ll1 with
LNil -> ll2
| LCons(x, xf) -> LCons(x, function () -> (xf()) @$ ll2);;

let ll1 = LCons(2,function ()->LCons(1,function ()->LNil));;
let ll2 = lfrom 3;;
let lpoj = LCons(4, function ()->LNil);;
ltake (10, ll1 @$ ll2);;

let rec lrepeat =
	m

	| LNil ->LNil
	| LCons(x, xf) ->LCons(x, function () -> xf());;
let repeat m n=
let rec lr l k counter= 
	match (k, l)with
| (_, LNil) -> LNil
| (0, _) -> LNil in k =counter 
| (n, LCons(x,xf)) -> LCons(x, function () -> lr l (n-1) (counter+1)

in lr m n 0;;


lr lpoj 5;;
ltake(6, lr lpoj 5);;
ltake(6,repeating ll1 5);;

	let rec lmap f = function
	LNil -> LNil
| LCons(x,xf) -> LCons(f x, function () -> lmap f (xf()) )
;;

let sqr_llist = lmap (function x -> x*x);;

ltake (6, lll (lfrom 3));;


let rec lfilter pred = function
LNil -> LNil
| LCons(x,xf) -> if pred x
then LCons(x, function () -> lfilter pred (xf()) )
else lfilter pred (xf())
;;

let rec liter f x = LCons(x, function () -> liter f (f x));;
let primes =
	let rec sieve = function
	LCons(p,nf) -> LCons( p,	function () -> sieve(lfilter (function n -> n mod p <> 0)
(nf())
)
)
| LNil -> failwith "Impossible! Internal error."
in sieve (lfrom 2)
;;
ltake (6,primes);;

let rec ltakeWithTail = function
(0, xq) -> ([],xq)
| (_, LNil) -> ([],LNil)
| (n, LCons(x,xf)) ->let (l,tail)=ltakeWithTail(n-1, xf())
in (x::l,tail);;



