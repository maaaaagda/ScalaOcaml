
//listy leniwe**************************************************************************************************************************
type 'a llist = LNil | LCons of 'a * (unit -> 'a llist);;

let lhd = function
LNil -> failwith "lhd"
| LCons (x, _) -> x
;;

let ltl = function
LNil -> failwith "ltl"
| LCons (_, xf) -> xf()
;;

let rec lfrom k = LCons (k, function () -> lfrom (k+1));;
let rec ltake = function
(0, _) -> []
| (_, LNil) -> []
| (n, LCons(x,xf)) -> x::ltake(n-1, xf())
;;

ltake (5,lfrom 30);;

let rec toLazyList = function
[] -> LNil
h::t -> LCons(h, function () -> toLazyList t);;

let rec (@$) ll1 ll2 =
match ll1 with
LNil -> ll2
| LCons(x, xf) -> LCons(x, function () -> (xf()) @$ ll2);;

let ll1 = LCons(2,function ()->LCons(1,function ()->LNil));;
let ll2 = lfrom 3;;
ltake (10, ll1 @$ ll2);;

let lrepeat =

	| LNil ->LNil
	| LCons(x, xf) ->LCons(x, function () -> xf());;

let rec lr l k= 
	match (k, l)with
| (_, LNil) -> LNil
| (0, _) -> LNil
| (n, LCons(x,xf)) -> lr (LCons(x, function () -> x())) (n-1);;

	let rec lmap f = function
LNil -> LNil
| LCons(x,xf) -> LCons(f x, function () -> lmap f (xf()) )
;;

let sqr_llist = lmap (function x -> x*x);;
ltake (6, sqr_llist (lfrom 3));;
